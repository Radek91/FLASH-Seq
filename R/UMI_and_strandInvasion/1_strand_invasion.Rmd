---
title: "UMI - Data Analysis"
author: "V. Hahaut, D. Pavlinic & S. Picelli."
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---

```{r Prerequisits, echo = FALSE, include = TRUE, warning = FALSE, comment = FALSE, message = FALSE, cache = FALSE}

options(scipen=999)

# 1. LIBRARIES / FUNCTIONS
library(SummarizedExperiment)
library(tidyverse)
library(cowplot)
source("/home/vincent.hahaut/Desktop/FLASH-Seq/R/general/4_aggregate_files_functions.R")

# 2. ANNOTATIONS
gtf.path <- "/home/vincent.hahaut/data_storage/REFERENCES/hsap_fastsmart/REFERENCE/GTF/gencode.v34.primary_assembly.annotation.gtf"
gtf <- rtracklayer::import(gtf.path)
codingIDs <- gtf$gene_name[gtf$gene_type == "protein_coding"]

# 3. COLORS
mycolors <- as.vector(c(RColorBrewer::brewer.pal(name = "Dark2", 8),
                        yarrr::piratepal("basel"), 
                        yarrr::piratepal("nemo"), 
                        yarrr::piratepal("appletv"), 
                        yarrr::piratepal("pony"), 
                        yarrr::piratepal("info"),
                        yarrr::piratepal("decision")[-4],
                        yarrr::piratepal("ipod")))

methodPalette <- function(){scale_fill_manual(values = c("FS" = "#E41A1C",
                                                         "SS2" = "#377EB8",
                                                         "SS3" = "#4DAF4A",
                                                         "SSsc" = "#984EA3")
)}
```


```{r UMI invasion - Tn5, echo = FALSE, include = TRUE, warning = FALSE, comment = FALSE, message = FALSE, cache = FALSE}

## GOAL: For each mapped UMI reads get the adjacent sequence and assess if an invasion event occured

#' getDownstreamSeq
#' 
#' Deduplicate UMI reads, extract the sequence adjacent to the read start and add some custom annotations to summarize the invasion events.
#' @param mybam, /path/to/UMI_annotated.sorted.filtered.bam files
#' @param myid, sample ID
#' @param METHOD, FLASH-Seq (=umi_tools/featurecounts) or zUMIs depending on the pre-processing steps
#' @param genome, Loaded BSgenome file
#' @param minReads, minimum number of reads to analyse the sample
getDownstreamSeq <- function(mybam = NULL, myid = NULL, METHOD = NULL, genome = genome, minReads = 5000){

  if(file.exists(mybam)){
    message(paste0("ID: ", myid))
    params <- ScanBamParam(what=c("qname","rname","strand","pos","mapq", "cigar")) 
    bam <- scanBam(mybam, param = params)
    message(paste0("reads:", length(bam[[1]]$qname)))

    if(length(bam[[1]]$qname) > minReads){
      message("Enough to start - This function is quite slow - needs to work on it later")
  
    # 1. Load Bam File
    # Allowed method:
    # UMI_TOOLS ==> Samples processed with UMI tools and no gene assignment info
    # zUMIS ==> Samples processed with zUMIs / Does not support the column "Gene" yet as zUMIs reports exon + intron in separated tags. 
    # UMI_TOOLS_FEATURECOUNTS ==> Samples processed with UMI tools and featurecounts
    if(METHOD == "UMI_TOOLS"){
      params <- ScanBamParam(what=c("qname","rname","strand","pos","mapq", "cigar")) 
      bam <- scanBam(mybam, param = params)
      
      qwidth <- lapply(str_extract_all(pattern = "\\d*[MNHPX]", bam[[1]]$cigar), function(x)
        str_replace_all(x, "[MN]", "") %>% 
          unlist() %>%
          as.numeric() %>%
          sum())
  
      gr <- makeGRangesFromDataFrame(
        data.frame(
          seqnames = bam[[1]]$rname,
          start = bam[[1]]$pos,
          end = bam[[1]]$pos + unlist(qwidth)-1,
          cigar = bam[[1]]$cigar,
          mapq = bam[[1]]$mapq,
          UMI = str_split(bam[[1]]$qname, "_", simplify = TRUE)[,2],
          strand = bam[[1]]$strand), 
        keep.extra.columns = TRUE)
    
    } else if (METHOD == "zUMIs"){
      params <- ScanBamParam(tag = c("GE", "GI", "UB"), what=c("qname","rname","strand","pos","mapq", "cigar")) 
      bam <- scanBam(mybam, param = params, flag=scanBamFlag(isNotPrimaryRead = FALSE, isFirstMateRead = TRUE, isDuplicate = FALSE, isNotPassingQualityControls = FALSE, isSupplementaryAlignment = FALSE, isUnmappedQuery=FALSE))
      
      qwidth <- lapply(str_extract_all(pattern = "\\d*[MNHPX]", bam[[1]]$cigar), function(x)
        str_replace_all(x, "[MN]", "") %>% 
          unlist() %>%
          as.numeric() %>%
          sum())
  
      gr <- makeGRangesFromDataFrame(
        data.frame(
          seqnames = bam[[1]]$rname,
          start = bam[[1]]$pos,
          end = bam[[1]]$pos + unlist(qwidth)-1,
          mapq = bam[[1]]$mapq,
          Assigned = "",
          exon = bam[[1]]$tag$GE,
          intron = bam[[1]]$tag$GI,
          cigar = bam[[1]]$cigar,
          UMI = bam[[1]]$tag$UB,
          strand = bam[[1]]$strand), 
        keep.extra.columns = TRUE) 
      
      gr <- gr[nchar(as.character(gr$UMI)) == 8]
      
      gr$Assigned <- ifelse(!is.na(gr$exon) | !is.na(gr$intron), "Assigned", "Unassigned")
  
    } else if(METHOD == "UMI_TOOLS_FEATURECOUNTS"){
      params <- ScanBamParam(tag = c("XS", "XT"), what=c("qname","rname","strand","pos","qwidth","mapq", "cigar")) 
      bam <- scanBam(mybam, param = params)
      
      # Compute the read end-of-mapping using CIGAR
      # While for read in +, start is enough to detect invasion, read in - you need the end
      # Only account for match (M) & skip (N = splicing)
      # Deletion, insertion do not influence start/end
      # Soft-clipping are not mapping
      # hard-cliping, seq mismatches, padding, are not observed in the data but still left here in case
      qwidth <- lapply(str_extract_all(pattern = "\\d*[MNHPX]", bam[[1]]$cigar), function(x)
        str_replace_all(x, "[MN]", "") %>% 
          unlist() %>%
          as.numeric() %>%
          sum())
      
      gr <- makeGRangesFromDataFrame(
        data.frame(
          seqnames = bam[[1]]$rname,
          start = bam[[1]]$pos,
          end = bam[[1]]$pos + unlist(qwidth)-1,
          mapq = bam[[1]]$mapq,
          UMI = str_split(bam[[1]]$qname, "_", simplify = TRUE)[,2],
          Assigned = bam[[1]]$tag$XS,
          Gene = bam[[1]]$tag$XT,
          strand = bam[[1]]$strand,
          cigar = bam[[1]]$cigar), 
        keep.extra.columns = TRUE)
    }
    
    # 2. Filter the GRanges
    # MAPQ > 5 / Main chromosomes
    gr <- gr[gr$mapq > 5]
    gr <- gr[seqnames(gr) %in% paste0("chr", 1:22)]
    
    if(length(gr) > minReads){
      # 3. Get the sequence upstream of the read start
      # 20bp before to account for potential mapping issues or long GGG's stretches created by the RT
      message("Get Upstream Sequences")
      
      gr$index <- 1:length(gr)
      gr.forward <- gr[strand(gr) == "+"]
      gr.reverse <- gr[strand(gr) == "-"]
      
      gr.forward.upstream <- GRanges(seqnames = seqnames(gr.forward), ranges = IRanges(start = start(gr.forward)-20, end = start(gr.forward)-1), strand = strand(gr.forward))
      gr.forward.upstream$index <- gr.forward$index
      # To extract the forward strand and match it to the UMI properly
      gr.reverse.upstream <- GRanges(seqnames = seqnames(gr.reverse), ranges = IRanges(start = end(gr.reverse)+1, end = end(gr.reverse)+20), strand(gr.reverse))
      gr.reverse.upstream$index <- gr.reverse$index
  
      gr.upstream <- c(gr.forward.upstream, gr.reverse.upstream)
      # Reorder
      gr.upstream <- gr.upstream[order(gr.upstream$index)]
      
      myseq.upstream <- Biostrings::getSeq(genome, gr.upstream)
      myseq.upstream <- as.data.frame(myseq.upstream)[,1]
    
      # 4. Combine results
      gr$upstream <- myseq.upstream
      gr.df <- mutate(as.data.frame(gr), 
                      READ_POS = paste0(seqnames, ":", start, "-", end),
                      READ_GROUP = paste0(seqnames, ":", start, "-", end, "-UMI:", UMI, "-upstream:", upstream)) 
      
      # 5. Collapse the data to remove duplicated
      # Based on the UMI, read mapping and upstream sequence
      message("Collapse UMI positions")
      collapsed <- gr.df %>%
        group_by(READ_POS, upstream, UMI) %>%
        summarise(
          READ_STRAND = unique(strand),
          PCR_duplicates = n(),
          READ_GROUP = unique(READ_GROUP)) %>%
        ungroup() %>%
        mutate(ID = myid,
               UNIQUE_MOLECULES = n(),
               nREADS = length(gr))
      
      collapsed.dim <- nrow(collapsed)
      # 6. Add back the mapping info
      # Could do that in the group_by + summary in (5) but this is much faster
      if(METHOD != "zUMIs"){
        collapsed <- left_join(collapsed, 
                               gr.df %>% 
                                 select(READ_GROUP, Assigned, Gene) %>% distinct(), by = "READ_GROUP")
      } else {
        collapsed <- left_join(collapsed, 
                               gr.df %>% 
                                 select(READ_GROUP, Assigned, exon, intron) %>% distinct(), by = "READ_GROUP")
      }
      
      # 7. In rare cases (<0.001%), reads with the same mapping positions (chr-start-end) can be assigned to different features
      # I think it comes from some secondary mappings not filtered (?).
      # For now just exclude them.
      dubs <- unique(collapsed$READ_GROUP[duplicated(collapsed$READ_GROUP)])
      message(paste0("ID: ", myid, " - % Duplicated Multi-assigned Features: ", round(100*length(dubs) / collapsed.dim,6)))
      message(paste0("Filter ", length(collapsed$ID[collapsed$READ_GROUP %in% dubs]), " reads"))
      collapsed <- filter(collapsed, !READ_GROUP %in% dubs)
        
      # 8. Find if the sequence upstream of the read matches the UMI
      message("Find Match")
      
      # 8.1. Create UMI pattern to search
      spacer <- case_when(grepl("5_SS3|6_SS3", myid) ~ "",
                          grepl("_AAGCA_", myid) ~ "AAGCA",
                          grepl("_CATCA_", myid) ~ "CATCA",
                          grepl("_CTGAC_", myid) ~ "CTGAC",                                    
                          grepl("_ATGAC_", myid) ~ "ATGAC",
                          grepl("_CTAAC_", myid) ~ "CTAAC",
                          grepl("SS3fwd", myid) ~ "",
                          grepl("STRToligoT_Spacer2", myid) ~ "ATAAC",
                          grepl("STRToligoT_Spacer1", myid) ~ "CAGCA",
                          grepl("STRToligoT_Fstso", myid) ~ "",
                          grepl("FSoligoT_Spacer2", myid) ~ "ATAAC",
                          grepl("FSoligoT_Spacer1", myid) ~ "CAGCA",
                          grepl("FSoligoT_FStso", myid) ~ "",
                          grepl("SS3oligoT_Spacer1", myid) ~ "CAGCA",
                          grepl("SS3oligoT_Fstso", myid) ~ "",
                          grepl("TSO_SS3_CAGCA", myid) ~ "CAGCA",
                          grepl("TSO_SS3_CTGAC", myid) ~ "CTGAC",
                          grepl("CGTAC", myid) ~ "CGTAC",
                          grepl("TSO_SS3_TATA", myid) ~ "TATA",
                          grepl("TSO_SS3_10x", myid) ~ "TTTCTTATAT",
                          grepl("TSO_SS3", myid) ~ "",
                          METHOD == "zUMIs" ~ "")
  
      collapsed$UMI.reversed <- as.data.frame(reverse(DNAStringSet(collapsed$UMI)))$x
      collapsed$UMI.spacer <- paste0(collapsed$UMI, spacer, "GGG")
  
      # 8.2. Look for the pattern in the upstream sequence
      # I observed several cases where there is a perfect match but not with the 5' bases of the UMI
      # Likelihood of getting 5' mismatches is higher than internal mismatches in primers so grepl is enough for now
      # But could be replaced later for partial matches (vmatchPattern)
      # Accounting for i mismatches (5')
      for(i in c(0,1,2,3)){
        
        umi <- as.character(substr(collapsed$UMI, 1+i, 8))
        umi.rev <- as.character(substr(collapsed$UMI.reversed, 1+i, 8))
        umi.sp <- as.character(substr(collapsed$UMI.spacer, 1+i, unique(nchar(collapsed$UMI.spacer))))
        
        matches.umi <- mapply(function(x,y) grepl(x, y), umi, collapsed$upstream)
        matches.rev <- mapply(function(x,y) grepl(x, y), umi.rev, collapsed$upstream)
        matches.spa <- mapply(function(x,y) grepl(x, y), umi.sp, collapsed$upstream)
        #
        matches.umi.perc <- 100 * sum(matches.umi) / nrow(collapsed)
        matches.rev.perc <- 100 * sum(matches.rev) / nrow(collapsed)
        matches.spa.perc <- 100 * sum(matches.spa) / nrow(collapsed)
  
        matches.df <- data.frame(matches.umi, matches.rev, matches.spa,matches.umi.perc,matches.rev.perc,matches.spa.perc)
        mismatches <- ifelse(i != 0, paste0(".",i), "")
        
        colnames(matches.df) <- c(paste0("MATCH", mismatches), paste0("MATCH.rev",mismatches), paste0("MATCH", mismatches, ".G"),
                                  paste0("PERCENTAGE_MATCH", mismatches), paste0("PERCENTAGE_MATCH.rev", mismatches), paste0("PERCENTAGE_MATCH", mismatches, ".G"))
          
        print(paste0("Percentage Match (UMI) with ", i, " mismatches: ", round(100 * sum(matches.umi) / nrow(collapsed), 3)))
        print(paste0("Percentage Match rev(UMI) with ", i, " mismatches: ", round(100 * sum(matches.rev) / nrow(collapsed), 3)))
        print(paste0("Percentage Match (UMI-GGG-Spacer) with ", i, " mismatches: ", round(100 * sum(matches.spa) / nrow(collapsed), 3)))
        
        collapsed <- bind_cols(collapsed, matches.df)
  
      }
      
      # 9. Strand Invasion does not waited the UMI to occur. GGG is often enough
      motif <- substr(collapsed$upstream, 17,20)
      collapsed$GGG <- motif == "GGG"
  
      collapsed$PERCENTAGE_MATCH.GGG <- 100 * sum(motif == "GGG") / nrow(collapsed)
  
      # 10. Add Groups
      collapsed <-  mutate(collapsed, GROUP = case_when(grepl("5_SS3|6_SS3", ID) ~ "SS3",
                                                  grepl("TSO_SS3_CAGCA", ID) ~ "TSO-CAGCA\nSS3-dT",
                                                  grepl("TSO_SS3_CTGAC", ID) ~ "TSO-CTGAC\nSS3-dT",
                                                  grepl("TSO_FS_CGTAC", ID) ~ "TSO-CGTAC\nSTRT-dT",
                                                  grepl("TSO_SS3_TATA", ID) ~ "TSO-TATA\nSS3-dT",
                                                  grepl("TSO_SS3_10", ID) ~ "TSO-10x\nSS3-dT",
                                                  grepl("_AAGCA_", ID) ~ "TSO-AAGCA\nSTRT-dT",
                                                  grepl("_CATCA_", ID) ~ "TSO-CATCA\nSTRT-dT",
                                                  grepl("_CTGAC_", ID) ~ "TSO-CTGAC\nSTRT-dT",
                                                  grepl("_ATGAC_", ID) ~ "TSO-ATGAC\nSTRT-dT",
                                                  grepl("_CTAAC_", ID) ~ "TSO-CTAAC\nSTRT-dT",
                                                  grepl("SS3-CGTAC", ID) ~  "TSO-SS3-CGTAC\nSS3-dT",
                                                  grepl("SS3fwd", ID) ~ "SS3\nHagemann-J.",
                                                  grepl("STRToligoT_Spacer2", ID) ~ "TSO-ATAAC\nSTRT-dT",
                                                  grepl("STRToligoT_Spacer1", ID) ~ "TSO-CAGCA\nSTRT-dT",
                                                  grepl("STRToligoT_Fstso", ID) ~ "TSO-FS-UMI\nSTRT-dT",
                                                  grepl("FSoligoT_Spacer2", ID) ~ "TSO-ATAAC\nFS-dT",
                                                  grepl("FSoligoT_Spacer1", ID) ~ "TSO-CAGCA\nFS-dT",
                                                  grepl("FSoligoT_FStso", ID) ~ "TSO-FS-UMI\nFS-dT",
                                                  grepl("SS3oligoT_Spacer1", ID) ~ "TSO-CAGCA\nSS3-dT",
                                                  grepl("SS3oligoT_Fstso", ID) ~ "TSO-FS-UMI\nSS3-dT",
                                                  grepl("277_TSO_SS3", ID) ~ "TSO-SS3\nSS3-dT",
                                                  METHOD == "zUMIs" ~ "zUMIs - SS3\nHagemann-J."),
                           ID = ID) 
      
      return(collapsed)
      }

  }

    }

}
  
# 1. Load the libraries
library(BSgenome.Hsapiens.UCSC.hg38)
genome <- BSgenome.Hsapiens.UCSC.hg38
#genome <- FaFile('/home/vincent.hahaut/data_storage/REFERENCES/mmu/NCBIM37.genome.fa')
# names(genome) <- str_split(names(genome), " ", simplify = T)[,1]
library(seqLogo)
library(tidyverse)
library(Rsamtools)
library(cowplot)
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(doSNOW))
suppressPackageStartupMessages(library(doParallel))

if(!file.exists("/home/vincent.hahaut/data_storage/FS_intermediate_file/bias.selected.umi.rds")){

  # 2. Prepare for multithreading
  cl <- makeCluster(8)
  registerDoSNOW(cl)
  clusterCall(cl, function() library(tidyverse))
  clusterCall(cl, function() library(Rsamtools))
  clusterCall(cl, function() library(BSgenome.Hsapiens.UCSC.hg38))
  
  # 3. Get the BAM paths, ID and "method" info
  pattern <- "_UMI_Aligned.sortedByCoord.filtered.bam.featureCounts.bam$"

  # Samples processed with FLASH-Seq pipeline
  # In addition Hagemann-Jensen et al samples processed with FLASH-Seq pipeline or zUMIs
  mypaths <- bind_rows(
      data_frame(
      bam.path = list.files("/home/vincent.hahaut/data_storage/210322_NB551561_0044_AHNTL2AFX2/STAR/", pattern = pattern, recursive = TRUE, full.names = TRUE),
      IDs =  str_split(list.files("/home/vincent.hahaut/data_storage/210322_NB551561_0044_AHNTL2AFX2/STAR/", pattern = pattern, recursive = TRUE, full.names = FALSE), "/", simplify = TRUE)[,1],
      METHOD = "UMI_TOOLS_FEATURECOUNTS"),
  data_frame(
    bam.path = list.files("/home/vincent.hahaut/data_storage/SMART_SEQ3/HEK/zUMIs_output/demultiplexed/", pattern = ".demx.bam$", recursive = TRUE, full.names = TRUE),
    IDs =  str_replace_all(list.files("/home/vincent.hahaut/data_storage/SMART_SEQ3/HEK/zUMIs_output/demultiplexed/", pattern = ".demx.bam$", recursive = TRUE, full.names = FALSE), "Smartseq3\\.|\\.demx\\.bam", ""),
    METHOD = "zUMIs")
  )
  
  # Pipeline tested in three different conditions. All with similar results
  # UMI reads mapped to exon / intron unstranded
  # UMI reads mapped to exon stranded
  # UMI reads mapped to genes stranded
  TYPE = "EXONINTRON"
  if(TYPE == "EXONINTRON"){
    suffix <- "exon_intron_unstranded"
    mypaths <- mypaths[grepl(mypaths$bam.path, pattern = "FEATURECOUNTS/EXONINTRON|.demx.bam$"),]
  } else if(TYPE == "EXON"){
    suffix <- "exon_stranded"
    mypaths <- mypaths[grepl(mypaths$bam.path, pattern = "FEATURECOUNTS/EXON/|.demx.bam$"),]
  } else if(TYPE == "GENE"){
    suffix <- "gene_stranded"
    mypaths <- mypaths[grepl(mypaths$bam.path, pattern = "FEATURECOUNTS/GENE|.demx.bam$"),]
  }
  
  # 4. Get the upstream seq & matching UMI
  res <- foreach(i = 1:nrow(mypaths)) %dopar% {
    getDownstreamSeq(mybam = mypaths$bam.path[i], myid = mypaths$IDs[i], METHOD = mypaths$METHOD[i], genome = genome)
  }
    
  # 5. Stop the multi-threadhing
  stopCluster(cl)
   
  # 6. zUMIs output exon / intron tags and not genes
  res.combined <- bind_rows(res)
  
  # 7. Intermediate - Save the data
  write_rds(res.combined, paste0("/home/vincent.hahaut/data_storage/FS_intermediate_file/bias.umi.", suffix,".rds"))
}
```


```{r UMI invasion - Visualize results, echo = FALSE, include = TRUE, warning = FALSE, comment = FALSE, message = FALSE, cache = FALSE}

# GOAL: get the percentage of invasion
# Varying edit distances
# Based on exon - stranded data
res.annotated.final <- read_rds("/home/vincent.hahaut/data_storage/FS_intermediate_file/bias.umi.exon_stranded.rds") %>% 
  filter(Assigned == "Assigned") 

# 1. Reformat the data
dat <- res.annotated.final %>%
  mutate(GROUP = ifelse(GROUP == "SS3\nHagemann-J.", "SS3\nHagemann-J. et al", GROUP)) %>%
  filter(GROUP != "zUMIs - SS3\nHagemann-J.") %>% 
  select(PERCENTAGE_MATCH, PERCENTAGE_MATCH.1, PERCENTAGE_MATCH.2, PERCENTAGE_MATCH.3, PERCENTAGE_MATCH.1.G,PERCENTAGE_MATCH.G, PERCENTAGE_MATCH.2.G, PERCENTAGE_MATCH.3.G, ID, GROUP) %>%
  distinct() %>%
  gather(mismatch, percentage, -GROUP, -ID) %>%
  mutate(SUBGROUPS = case_when(GROUP %in% c("zUMIs - SS3\nHagemann-J.", "SS3", "SS3\nHagemann-J. et al") ~ "SS3",
                               grepl("TSO-ATAAC|TSO-ATAAC|TSO-AAGCA|TSO-CATCA|TSO-CTGAC|TSO-ATGAC|TSO-CTAAC|TSO-CAGCA|TSO-TATA|TSO-CGTAC|TSO-10x", GROUP) ~ "SPACER",
                               TRUE ~ "FS-UMI"),
         mismatchN = case_when(mismatch %in% c("PERCENTAGE_MATCH", "PERCENTAGE_MATCH.G") ~ 0,
                              mismatch %in% c("PERCENTAGE_MATCH.1", "PERCENTAGE_MATCH.1.G")  ~ 1,
                              mismatch %in% c("PERCENTAGE_MATCH.2", "PERCENTAGE_MATCH.2.G")  ~ 2,
                              mismatch %in% c("PERCENTAGE_MATCH.3", "PERCENTAGE_MATCH.3.G")  ~ 3),
         GGG = case_when(mismatch %in% c("PERCENTAGE_MATCH.G", "PERCENTAGE_MATCH.1.G", "PERCENTAGE_MATCH.2.G", "PERCENTAGE_MATCH.3.G") & SUBGROUPS == "SPACER" ~ "5'-UMI-(Spacer)-GGG-3'",
                         mismatch %in% c("PERCENTAGE_MATCH.G", "PERCENTAGE_MATCH.1.G", "PERCENTAGE_MATCH.2.G", "PERCENTAGE_MATCH.3.G") & SUBGROUPS %in% c("SS3", "FS-UMI") ~ "5'-UMI-GGG-3'",
                         TRUE ~ "5'-UMI-3'"),
         facet = factor(paste0(GGG, "\n", SUBGROUPS), levels = c(
           "5'-UMI-3'\nSS3", "5'-UMI-3'\nFS-UMI","5'-UMI-3'\nSPACER",
           "5'-UMI-GGG-3'\nSS3",  "5'-UMI-GGG-3'\nFS-UMI", "5'-UMI-(Spacer)-GGG-3'\nSPACER" )),
         percentage = as.numeric(percentage),
         SUBGROUPS = factor(SUBGROUPS, levels = c("SS3", "FS-UMI", "SPACER")))

# 2. Graphics Functions
invasion.plot <- function(group, suffix = "group1"){
    p.perfect <- ggplot(filter(dat, mismatchN == 0, GROUP %in% group), aes(x = GROUP, fill = GROUP, y = percentage)) + 
    geom_hline(yintercept = seq(0,7.5,1), linetype = "dashed", color = "darkgrey") +
    geom_boxplot(width = 0.75) +
    theme_bw(base_size = 21, base_family = "arial") +
    facet_wrap(~SUBGROUPS, ncol = 2, scales = "free_x") +
    scale_fill_manual(values = c("SS3" = "#e6194B",
  "TSO-ATAAC\nSTRT-dT"= "#3cb44b",
  "TSO-CAGCA\nSTRT-dT"= "#ffe119",
  "TSO-FS-UMI\nSTRT-dT"= "#4363d8",
  "TSO-ATAAC\nFS-dT"= "#f58231",
  "TSO-CAGCA\nFS-dT"= "#42d4f4",
  "TSO-FS-UMI\nFS-dT"= "#f032e6",
  "TSO-CAGCA\nSS3-dT"= "#fabed4",
  "TSO-FS-UMI\nSS3-dT"= "#469990",
  "SS3\nHagemann-J. et al" = "#dcbeff",
  "zUMIs - SS3\nHagemann-J." = "#B3B3B3",
  "TSO-AAGCA\nSTRT-dT" = '#9A6324',
  "TSO-CATCA\nSTRT-dT" ='#bfef45',
  "TSO-CTGAC\nSTRT-dT" = '#800000',
  "TSO-ATGAC\nSTRT-dT" ='#000075',
  "TSO-CTAAC\nSTRT-dT" = '#808000')) +
    ylab("% UMI-Upstream Sequence Match") +
    xlab("") +
    theme(legend.position = "none",
          axis.text.y = element_text(size = 20),
          axis.text.x = element_text(size = 13, angle = 45, hjust = 1))
  
    
  p.all.dat <- dat %>%
    filter(mismatchN < 4, GROUP %in% group) %>% 
  group_by(mismatchN, GGG, GROUP, SUBGROUPS, facet) %>%
  summarise(m = mean(percentage),
            s = sd(percentage))
  
    
           
  p.all.GGG <- filter(p.all.dat, facet %in% c("5'-UMI-GGG-3'\nSS3",  "5'-UMI-GGG-3'\nFS-UMI", "5'-UMI-(Spacer)-GGG-3'\nSPACER")) %>%
    ggplot(aes(x = mismatchN, ymin = m-s, ymax = m+s, y = m, color = GROUP)) +
    geom_pointrange() +
    #ylim(c(0,20.5)) +
    geom_line(aes(y = m, group = GROUP)) +
    facet_wrap(~SUBGROUPS, nrow = 1) +
    scale_color_manual(values = c("SS3" = "#e6194B",
  "TSO-ATAAC\nSTRT-dT"= "#3cb44b",
  "TSO-CAGCA\nSTRT-dT"= "#ffe119",
  "TSO-FS-UMI\nSTRT-dT"= "#4363d8",
  "TSO-ATAAC\nFS-dT"= "#f58231",
  "TSO-CAGCA\nFS-dT"= "#42d4f4",
  "TSO-FS-UMI\nFS-dT"= "#f032e6",
  "TSO-CAGCA\nSS3-dT"= "#fabed4",
  "TSO-FS-UMI\nSS3-dT"= "#469990",
  "SS3\nHagemann-J. et al" = "#dcbeff",
  "zUMIs - SS3\nHagemann-J. et al" = "#B3B3B3",
  "TSO-AAGCA\nSTRT-dT" = '#9A6324',
  "TSO-CATCA\nSTRT-dT" ='#bfef45',
  "TSO-CTGAC\nSTRT-dT" = '#800000',
  "TSO-ATGAC\nSTRT-dT" ='#000075',
  "TSO-CTAAC\nSTRT-dT" = '#808000')) +
    theme_bw(base_size = 28) +
    theme(legend.position = "none",
          legend.title = element_blank(),
          strip.text = element_text(face = "bold")) +
    scale_x_continuous(breaks = c(0,1,2,3), limits = c(0,3)) +
    xlab("Number of Consecutive 5' Mismatches in UMI") + 
    ylab("Match Upstream\nSequence (%)") 

           
  p.all <- filter(p.all.dat, facet %in% c("5'-UMI-3'\nSS3", "5'-UMI-3'\nFS-UMI","5'-UMI-3'\nSPACER")) %>%
    ggplot(aes(x = mismatchN, ymin = m-s, ymax = m+s, y = m, color = GROUP)) +
    geom_pointrange() +
    #ylim(c(0,20.5)) +
    geom_line(aes(y = m, group = GROUP)) +
    facet_wrap(~SUBGROUPS, nrow = 1) +
    scale_color_manual(values = c("SS3" = "#e6194B",
  "TSO-ATAAC\nSTRT-dT"= "#3cb44b",
  "TSO-CAGCA\nSTRT-dT"= "#ffe119",
  "TSO-FS-UMI\nSTRT-dT"= "#4363d8",
  "TSO-ATAAC\nFS-dT"= "#f58231",
  "TSO-CAGCA\nFS-dT"= "#42d4f4",
  "TSO-FS-UMI\nFS-dT"= "#f032e6",
  "TSO-CAGCA\nSS3-dT"= "#fabed4",
  "TSO-FS-UMI\nSS3-dT"= "#469990",
  "SS3\nHagemann-J. et al" = "#dcbeff",
  "zUMIs - SS3\nHagemann-J. et" = "#B3B3B3",
  "TSO-AAGCA\nSTRT-dT" = '#9A6324',
  "TSO-CATCA\nSTRT-dT" ='#bfef45',
  "TSO-CTGAC\nSTRT-dT" = '#800000',
  "TSO-ATGAC\nSTRT-dT" ='#000075',
  "TSO-CTAAC\nSTRT-dT" = '#808000',
  "LA-TSO-CAGCA\nSTRT-dT" = "#dcbeff")) +
    theme_bw(base_size = 28) +
    theme(legend.position = "none",
          legend.title = element_blank(),
          strip.text = element_text(face = "bold")) +
    scale_x_continuous(breaks = c(0,1,2,3), limits = c(0,3)) +
    xlab("Number of Consecutive 5' Mismatches in UMI") + 
    ylab("Match Upstream\nSequence (%)") 

  ggsave(p.perfect, filename = paste0( "/home/vincent.hahaut/data_storage/FS_intermediate_file/FIGURES/StrandInvasion_Perfect.", suffix,".pdf"), dpi= 450, height = 5.4*length(unique(filter(dat,GROUP %in% group)$SUBGROUPS)), width = 12)
  ggsave(p.all, filename = paste0("/home/vincent.hahaut/data_storage/FS_intermediate_file/FIGURES/StrandInvasion_Mismatch.", suffix,".pdf"), dpi= 450, width = 10, height = 5)
  ggsave(p.all.GGG, filename = paste0("/home/vincent.hahaut/data_storage/FS_intermediate_file/FIGURES/StrandInvasion_Mismatch.", suffix,".GGG.pdf"), dpi= 450, width = 10, height = 5)

}
  
group1 <- c("SS3","TSO-CAGCA\nSTRT-dT","TSO-AAGCA\nSTRT-dT", "TSO-CATCA\nSTRT-dT","TSO-CTGAC\nSTRT-dT","TSO-ATGAC\nSTRT-dT","TSO-CTAAC\nSTRT-dT", "TSO-ATAAC\nSTRT-dT","TSO-CAGCA\nSTRT-dT","TSO-FS-UMI\nSTRT-dT","SS3\nHagemann-J. et")
group2 <- c("TSO-ATAAC\nFS-dT","TSO-CAGCA\nFS-dT","TSO-FS-UMI\nFS-dT","TSO-CAGCA\nSS3-dT","TSO-FS-UMI\nSS3-dT")


group4 <- c("SS3","SS3\nHagemann-J. et al",
            "TSO-CAGCA\nSTRT-dT","TSO-CTAAC\nSTRT-dT",
            "TSO-FS-UMI\nSTRT-dT","TSO-FS-UMI\nFS-dT")

invasion.plot(group1, "group1")
invasion.plot(group2, "group2")
invasion.plot(c(group1, group2), "group3")
invasion.plot(group = group4, suffix = "group4")


# Seqlogo of the first adjacent bases
res.annotated.final <- mutate(res.annotated.final, SUBGROUPS = case_when(GROUP == "SS3" ~ "SS3",
                                                                         GROUP == "SS3\nHagemann-J." ~ "SS3\nHagemann-J.",
                               grepl("TSO-ATAAC|TSO-ATAAC|TSO-AAGCA|TSO-CATCA|TSO-CTGAC|TSO-ATGAC|TSO-CTAAC|TSO-CAGCA", GROUP) ~ "SPACER",
                               TRUE ~ "FS-UMI"))

p <- list()
for(i in unique(res.annotated.final$SUBGROUPS)){
  upstream <- filter(res.annotated.final, SUBGROUPS == i) %>%
  sample_n(size = 500000, replace = FALSE) %>% 
    dplyr::select(upstream, READ_STRAND)
    
  myseq <- substr(upstream$upstream, 15, 20)
  
  p[[i]] <- ggplot() + 
    ggseqlogo::geom_logo(seq_type = "DNA", 
                         method = "prob", 
                         col_scheme = "nucleotide", myseq) + 
  ggseqlogo::theme_logo(base_size = 24) +
  scale_x_continuous(breaks = seq(1:6), labels = c("6","5","4","3","2","1"))
  
}

ggsave(plot_grid(p[[1]], p[[2]],p[[3]], p[[4]], nrow = 1), bg = "white", filename = paste0("/home/vincent.hahaut/data_storage/FS_intermediate_file/FIGURES/seqlogo_upstream.GGG.pdf"), dpi= 450, height = 3, width = 16)

  
# Seqlogo of the Upstream sequences
p.upstream <- list()


for(i in c("SS3\nHagemann-J.", "TSO-FS-UMI\nSTRT-dT", "TSO-CTAAC\nSTRT-dT", "TSO-AAGCA\nSTRT-dT")){
  
  message(paste0("Processing: ", i))
  
  dat.match <- filter(res.annotated.final, GROUP== i, MATCH == TRUE)
  dat.nomatch <- filter(res.annotated.final, GROUP== i, MATCH == FALSE)
 
  p.match <- ggplot() + 
    ggseqlogo::geom_logo(seq_type = "DNA", 
                         method = "bits", 
                         col_scheme = "nucleotide", substr(dat.match$upstream, 5, 19)) + 
  ggseqlogo::theme_logo(base_size = 24) 
 
  p.unmatch <- ggplot() + 
    ggseqlogo::geom_logo(seq_type = "DNA", 
                         method = "bits", 
                         col_scheme = "nucleotide", substr(dat.nomatch$upstream, 5, 19)) + 
  ggseqlogo::theme_logo(base_size = 24) 
  
  p.upstream[[i]] <- plot_grid(p.match, p.unmatch, ncol = 2)
}

p.logo <- plot_grid(p.upstream[[1]],
          p.upstream[[2]],
          p.upstream[[3]],
          p.upstream[[4]],
          labels = c("SS3\nHagemann-J.", "TSO-FS-UMI\nSTRT-dT", "TSO-CTAAC\nSTRT-dT", "TSO-AAGCA\nSTRT-dT"), ncol = 2)
  
  
ggsave(p.logo, bg = "white", filename = "/home/vincent.hahaut/data_storage/FS_intermediate_file/FIGURES/seqlogo_upstream.pdf", dpi= 450, height = 24, width = 36)
```

```{r UMI invasion - read orientation, echo = FALSE, include = TRUE, warning = FALSE, comment = FALSE, message = FALSE, cache = FALSE}

# Invasion in intron / exons

# 1. Load file containing the sequence adjacent to the UMI
# UMI reads assigned to exon / intron features
res.annotated.final <- read_rds("/home/vincent.hahaut/data_storage/FS_intermediate_file/bias.umi.exon_intron_unstranded.rds")

# 2. Aggregate results
# Could probably clean-up this part
intron.exon.dat <- res.annotated.final %>% 
  filter(Assigned == "Assigned") %>%
  dplyr::select(GROUP,ID,READ_STRAND,Gene) %>%
  mutate(TYPE = str_extract(Gene, "EXON|INTRON"),
         GENE_STRAND = str_extract(Gene, "\\+$|\\-$"),
         ANTISENSE = GENE_STRAND != READ_STRAND) %>%
  group_by(ID, GROUP) %>%
  mutate(nREADS = n()) %>%
  group_by(ID, GROUP, TYPE, ANTISENSE) %>%
  summarise(perc = 100*n()/unique(nREADS)) %>%
  ungroup() %>%
  mutate(SUBGROUP = paste0(TYPE, " - ", ifelse(ANTISENSE == TRUE, "Discordant", "Concordant")))

group1 <- c("SS3 data from\nHagemann-J. et al", "TSO-FS-UMI\nSTRT-dT", "TSO-CTAAC\nSTRT-dT", "TSO-AAGCA\nSTRT-dT")

# 3. Significance level
intron.exon.dat.tmp <- mutate(intron.exon.dat,
         GROUP = ifelse(GROUP == "SS3\nHagemann-J.", "SS3 data from\nHagemann-J. et al", GROUP)) %>%
                              filter(GROUP %in% group1) 
p.signif <- intron.exon.dat.tmp %>%
  group_by(SUBGROUP) %>%
  rstatix::dunn_test(perc ~ GROUP, p.adjust.method = "bonferroni") %>%
  mutate(p.adj.signif = paste0("p=", formatC(p.adj, format = "e", digits = 2))) %>%
  filter(p.adj < 0.05) %>%
  rstatix::add_y_position(fun = "max", scales = "free")


# 4. Visualize:
p.sub <- list()
for(SUB in c("EXON - Concordant" ,  "EXON - Discordant",   "INTRON - Concordant", "INTRON - Discordant")){
  
  col <- case_when(
    SUB == "EXON - Concordant" ~ "#1B9E77", 
    SUB == "EXON - Discordant" ~ "#D95F02", 
    SUB == "INTRON - Concordant" ~ "#7570B3", 
    SUB == "INTRON - Discordant" ~ "#E7298A"
  )
  
  scales <- if(SUB == "EXON - Concordant"){
    seq(55,100,15)
  }  else if(SUB == "EXON - Discordant"){
    seq(0,5,1)
  } else if(SUB == "INTRON - Concordant"){
    seq(0,12.5,2.5)
  } else if(SUB == "INTRON - Discordant"){
     seq(0,25,5)
  }

  lims <- if(SUB == "EXON - Concordant"){
    c(55,125)
  }  else if(SUB == "EXON - Discordant"){
    c(0,9)
  } else if(SUB == "INTRON - Concordant"){
    c(0,21)
  } else if(SUB == "INTRON - Discordant"){
     c(0,45)
  }

  p.sub[[SUB]] <- ggplot() + 
  geom_violin(data = filter(intron.exon.dat.tmp, SUBGROUP == SUB), aes(x = GROUP, y = perc, fill = SUBGROUP)) + 
  geom_boxplot(data= filter(intron.exon.dat.tmp, SUBGROUP == SUB), aes(x = GROUP, y = perc, fill = SUBGROUP), width = 0.1, position = position_dodge(0.9)) +
  facet_wrap("SUBGROUP", scales = "free",  nrow = 2) + 
  theme_bw(base_size = 20) +
  theme(legend.position = "none", 
        axis.text.x = element_text(size = 16, angle = 45, hjust = 1),
        legend.title = element_blank(),
        legend.text = element_text(size = 16),
        strip.background = element_blank(),
        axis.line = element_blank(),
        strip.text = element_text(face = "bold", size = 18)) +
  scale_fill_manual(values = col) +
  scale_y_continuous(breaks = scales, limits = lims) +
  ylab("5'UMI-Reads (%)") +
  xlab("") +
  ggpubr::stat_pvalue_manual(filter(p.signif, SUBGROUP == SUB), label = "{p.adj.signif}",  step.increase = ifelse(SUB == "EXON - Concordant", 0.1, 0.032), tip.length = 0.01, size = 6) 
}


ggsave(plot_grid(nrow = 2,  p.sub[[1]], p.sub[[2]], p.sub[[3]], p.sub[[4]]), bg = "white", filename = paste0( "/home/vincent.hahaut/data_storage/FS_intermediate_file/FIGURES/strandInvasion_intronicReads.group1.pdf"), dpi= 450, height = 12, width = 12)


```


```{r seqLogo  UMI sequences, echo = FALSE, include = TRUE, warning = FALSE, comment = FALSE, message = FALSE, cache = FALSE}

library(ggseqlogo)

# SeqLogo UMI
# GOAL:  check the base distribution
# Not used in the final manuscripts

plogo <- plot_grid(ncol = 3,
  ggplot() + 
    geom_logo(seq_type = "DNA", 
              method = "bits", 
              col_scheme = "nucleotide", 
              as.character(sample_n(filter(res.annotated.final, GROUP == "SS3"), 5e4, replacement = F)$UMI)) + 
    theme_logo(base_size = 24) + 
    ggtitle("SS3") + 
    ylim(c(0,0.25)),
  #
  ggplot() + 
    geom_logo(seq_type = "DNA", 
              method = "bits", 
              col_scheme = "nucleotide", 
              as.character(sample_n(filter(res.annotated.final, GROUP == "SS3\nHagemann-J."), 5e4, replacement = F)$UMI)) + 
    theme_logo(base_size = 24) + 
    ggtitle("SS3 Hagemann-J.") + 
    ylim(c(0,0.25)),
  # 
  ggplot() + 
    geom_logo(seq_type = "DNA", 
              method = "bits", 
              col_scheme = "nucleotide", 
              as.character(sample_n(filter(res.annotated.final, GROUP == "TSO-ATAAC\nSTRT-dT"), 5e4, replacement = F)$UMI)) + 
    theme_logo(base_size = 24) + 
    ggtitle("TSO-ATAAC+STRT-dT") + 
    ylim(c(0,0.25)),
  # 
  ggplot() + 
    geom_logo(seq_type = "DNA", 
              method = "bits", 
              col_scheme = "nucleotide", 
              as.character(sample_n(filter(res.annotated.final, GROUP == "TSO-CAGCA\nSTRT-dT"), 5e4, replacement = F)$UMI)) + 
    theme_logo(base_size = 24) + 
    ggtitle("TSO-CAGCA+STRT-dT") + 
    ylim(c(0,0.25)),
  # 
  ggplot() + 
    geom_logo(seq_type = "DNA", 
              method = "bits", 
              col_scheme = "nucleotide", 
              as.character(sample_n(filter(res.annotated.final, GROUP == "TSO-FS-UMI\nSTRT-dT"), 5e4, replacement = F)$UMI)) + 
    theme_logo(base_size = 24) + 
    ggtitle("TSO-FS-UMI+STRT-dT") + 
    ylim(c(0,0.25)),
  # 
  ggplot() + 
    geom_logo(seq_type = "DNA", 
              method = "bits", 
              col_scheme = "nucleotide", 
              as.character(sample_n(filter(res.annotated.final, GROUP == "TSO-ATAAC\nFS-dT"), 5e4, replacement = F)$UMI)) + 
    theme_logo(base_size = 24) + 
    ggtitle("TSO-ATAAC+FS-dT") + 
    ylim(c(0,0.25)),
  # 
  ggplot() + 
    geom_logo(seq_type = "DNA", 
              method = "bits", 
              col_scheme = "nucleotide", 
              as.character(sample_n(filter(res.annotated.final, GROUP == "TSO-CAGCA\nFS-dT"), 5e4, replacement = F)$UMI)) + 
    theme_logo(base_size = 24) + 
    ggtitle("TSO-CAGCA+FS-dT") + 
    ylim(c(0,0.25)),
  # 
  ggplot() + 
    geom_logo(seq_type = "DNA", 
              method = "bits", 
              col_scheme = "nucleotide", 
              as.character(sample_n(filter(res.annotated.final, GROUP == "TSO-FS-UMI\nFS-dT"), 5e4, replacement = F)$UMI)) + 
    theme_logo(base_size = 24) + 
    ggtitle("TSO-FS-UMI+FS-dT") + 
    ylim(c(0,0.25)),
  # 
  ggplot() + 
    geom_logo(seq_type = "DNA", 
              method = "bits", 
              col_scheme = "nucleotide", 
              as.character(sample_n(filter(res.annotated.final, GROUP == "TSO-CAGCA\nSS3-dT"), 5e4, replacement = F)$UMI)) + 
    theme_logo(base_size = 24) + 
    ggtitle("TSO-CAGCA+SS3-dT") + 
    ylim(c(0,0.25)),
  # 
  ggplot() + 
    geom_logo(seq_type = "DNA", 
              method = "bits", 
              col_scheme = "nucleotide", 
              as.character(sample_n(filter(res.annotated.final, GROUP == "TSO-FS-UMI\nSS3-dT"), 5e4, replacement = F)$UMI)) + 
    theme_logo(base_size = 24) + 
    ggtitle("TSO-FS-UMI+SS3-dT") + 
    ylim(c(0,0.25)),
  #
  ggplot() + 
    geom_logo(seq_type = "DNA", 
              method = "bits", 
              col_scheme = "nucleotide", 
              as.character(sample_n(filter(res.annotated.final, GROUP == "zUMIs - SS3\nHagemann-J."), 5e4, replacement = F)$UMI)) + 
    theme_logo(base_size = 24) + 
    ggtitle("zUMIs - Hagemann-J. et al") + 
    ylim(c(0,0.25))
)

ggsave(plogo, filename = "/home/vincent.hahaut/data_storage/FS_intermediate_file/FIGURES/ggseqlogo.pdf", dpi = 450, height = 16, width = 24)

```


#### ARCHIVE

### UMI - Tn5 - Spacer relation
# Mainly moved to UMI in R2
# Not used in the main paper but could still be useful in case of questions

```{r TSO Spacer - Tn5, echo = FALSE, include = TRUE, warning = FALSE, comment = FALSE, message = FALSE, cache = FALSE}

# GOAL: Observe the Tn5 cut in R1 of FS-UMI / SS3

## 1. PAIRED-END PBMCs
if(!file.exists("/home/vincent.hahaut/data_storage/FS_intermediate_file/TSO_motifs.pos.rds")){
  
  ## Where does the cut occur ?
  
  # 1. Read FASTQ R1 files
  R1 <-list.files("/home/vincent.hahaut/data_storage/PBMC_PAIREDEND/out/", full.names = TRUE, pattern = "_R1_")
  R2 <-list.files("/home/vincent.hahaut/data_storage/PBMC_PAIREDEND/out/", full.names = TRUE, pattern = "_R2_")
  IDs <- str_replace(list.files("/home/vincent.hahaut/data_storage/PBMC_PAIREDEND/out/", full.names = FALSE, pattern = "_R1_"), pattern = "_S[0-9]+_R1_001.fastq.gz", "")
  
  R1 <- R1[!grepl("354", R1)]
  R2 <- R2[!grepl("354", R2)]
  IDs <- IDs[!grepl("354", IDs)]
  
  mymotifs <- data.frame()
  for(i in 1:length(R1)){
    
    # 2. Read File
    fq.R1 <- ShortRead::sread(ShortRead::readFastq(R1[i]))
    fq.R2 <- ShortRead::sread(ShortRead::readFastq(R2[i]))

    # 3. Extract the TSO position in the read (prior to UMI extraction)
    # In order to keep in simple, expect perfect matching

    # 3.1. Define the Pattern to search for
    # SS3 is a more complicated case as it we can't exactly rely on any spacer sequence to localise the UMI in case of cut
    pattern = case_when(
      grepl("5_SS3|6_SS3|SS3fwd|385_", IDs[i]) ~ "GCAATG........GG",
      grepl("STRToligoT_Spacer2|FSoligoT_Spacer2", IDs[i]) ~ "GT........ATAACGG",
      grepl("STRToligoT_Spacer1|FSoligoT_Spacer1|SS3oligoT_Spacer1", IDs[i]) ~ "GT........CAGCAGG",
      grepl("AAGCA", IDs[i]) ~ "GT........AAGCAGG",
      grepl("CATCA", IDs[i]) ~ "GT........CATCAGG",
      grepl("CTGAC", IDs[i]) ~ "GT........ATGACGG",
      grepl("ATGAC", IDs[i]) ~ "GT........ATGACGG",
      grepl("CTAAC|382_", IDs[i]) ~ "GT........CTAACGG",
      grepl("STRToligoT_Fstso|FSoligoT_FStso|SS3oligoT_Fstso", IDs[i]) ~ "AGAGT........GG")
    
    starts.R1 <- regexpr(pattern, fq.R1)
    starts.R2 <- regexpr(pattern, fq.R2)
    starts.R1 <- starts.R1[!starts.R1 == -1]
    starts.R2 <- starts.R2[!starts.R2 == -1]

    mymotifs <- bind_rows(mymotifs,
                          data_frame(ID = IDs[i],
                                     starts = starts.R1,
                                     TYPE = "R1",
                                     pattern.match = length(starts.R1)),
                          data_frame(ID = IDs[i],
                                     starts = starts.R2,
                                     TYPE = "R2",
                                     pattern.match = length(starts.R2))) %>%
      group_by(ID, TYPE, starts, pattern.match) %>%
      summarise(n = n(), 
                perc = 100*n()/unique(pattern.match))
  }

  motifs <- mutate(mymotifs, 
                   GROUP = case_when(grepl("5_SS3|6_SS3|385_", ID) ~ "SS3",
             grepl("SS3fwd", ID) ~ "SS3\nHagemann-J.",
             grepl("STRToligoT_Spacer2", ID) ~ "TSO-ATAAC\nSTRT-dT",
             grepl("STRToligoT_Spacer1", ID) ~ "TSO-CAGCA\nSTRT-dT",
             grepl("AAGCA", ID) ~ "TSO-AAGCA\nSTRT-dT",
             grepl("CATCA", ID) ~ "TSO-CATCA\nSTRT-dT",
             grepl("CTGAC", ID) ~ "TSO-CTGAC\nSTRT-dT",
             grepl("ATGAC", ID) ~ "TSO-ATGAC\nSTRT-dT",
             grepl("CTAAC|382_", ID) ~ "TSO-CTAAC\nSTRT-dT",
             grepl("LA_TSOspacer1", ID) ~ "LA-TSO-CAGCA\nSTRT-dT",
             grepl("STRToligoT_Fstso", ID) ~ "TSO-FS-UMI\nSTRT-dT",
             grepl("FSoligoT_Spacer2", ID) ~ "TSO-ATAAC\nFS-dT",
             grepl("FSoligoT_Spacer1", ID) ~ "TSO-CAGCA\nFS-dT",
             grepl("FSoligoT_FStso", ID) ~ "TSO-FS-UMI\nFS-dT",
             grepl("SS3oligoT_Spacer1", ID) ~ "TSO-CAGCA\nSS3-dT",
             grepl("SS3oligoT_Fstso", ID) ~ "TSO-FS-UMI\nSS3-dT"))
  
  write_rds(motifs, "/home/vincent.hahaut/data_storage/FS_intermediate_file/TSO_motifs.pos.rds")
}

# Visualize
ggplot() + 
  geom_boxplot(data = motifs, aes(y = as.numeric(mean), x = as.factor(starts), fill = GROUP)) +
  xlab("Motif Position") +
  ylab("Mean Reads Percentage") +
  facet_wrap("GROUP") +
  theme_bw() +
  ylim(c(0,115)) +
  theme(legend.position = "none") +
  geom_text(data = primer, aes(x = starts, label = label), y = 110) +
  geom_text(data = primer2, aes(x = starts, label = label), y = 105) +
  geom_text(data = primer3, aes(x = starts, label = label), y = 100) +
  geom_segment(data = mysegs, aes(x = as.factor(starts), xend = as.factor(starts), y = 0, yend = yend), linetype = "dashed", color = "darkred") 




mygroups <- c("SS3","TSO-ATAAC\nSTRT-dT","TSO-CAGCA\nSTRT-dT","TSO-AAGCA\nSTRT-dT",
"TSO-CATCA\nSTRT-dT","TSO-CTGAC\nSTRT-dT","TSO-ATGAC\nSTRT-dT","TSO-CTAAC\nSTRT-dT","TSO-FS-UMI\nSTRT-dT","TSO-ATAAC\nFS-dT","TSO-CAGCA\nFS-dT","TSO-FS-UMI\nFS-dT","TSO-CAGCA\nSS3-dT","TSO-FS-UMI\nSS3-dT")
mygroups2 <- c("TSO-CAGCA\nSTRT-dT","TSO-AAGCA\nSTRT-dT",
"TSO-CATCA\nSTRT-dT","TSO-CTGAC\nSTRT-dT","TSO-ATGAC\nSTRT-dT","TSO-CTAAC\nSTRT-dT","TSO-CAGCA\nFS-dT","TSO-CAGCA\nSS3-dT")

primer <- data_frame(
  GROUP = mygroups,
  label = case_when(
    GROUP == "SS3" ~ "ATTGCGCAATGNNNNNNNNGGG",
    GROUP == "TSO-ATAAC\nSTRT-dT"~ "AAGCAGTGGTATCAACGCAGAGTNNNNNNNNATAACGGG",
    GROUP == "TSO-CAGCA\nSTRT-dT"~ "AAGCAGTGGTATCAACGCAGAGTNNNNNNNNCAGCAGGG",
    GROUP == "TSO-AAGCA\nSTRT-dT"~ "AAGCAGTGGTATCAACGCAGAGTNNNNNNNNAAGCAGGG",
    GROUP == "TSO-CATCA\nSTRT-dT" ~ "AAGCAGTGGTATCAACGCAGAGTNNNNNNNNCATCAGGG",
    GROUP == "TSO-CTGAC\nSTRT-dT" ~ "AAGCAGTGGTATCAACGCAGAGTNNNNNNNNCTGACGGG",
    GROUP == "TSO-ATGAC\nSTRT-dT" ~ "AAGCAGTGGTATCAACGCAGAGTNNNNNNNNATGACGGG",
    GROUP == "TSO-CTAAC\nSTRT-dT" ~ "AAGCAGTGGTATCAACGCAGAGTNNNNNNNNCTAACGGG",
    GROUP == "TSO-FS-UMI\nSTRT-dT" ~ "AAGCAGTGGTATCAACGCAGAGTNNNNNNNNGGG",
    GROUP == "TSO-ATAAC\nFS-dT" ~ "AAGCAGTGGTATCAACGCAGAGTNNNNNNNNATAACGGG",
    GROUP == "TSO-CAGCA\nFS-dT" ~ "AAGCAGTGGTATCAACGCAGAGTNNNNNNNNCAGCAGGG",
    GROUP == "TSO-FS-UMI\nFS-dT" ~ "AAGCAGTGGTATCAACGCAGAGTNNNNNNNNGGG",
    GROUP == "TSO-CAGCA\nSS3-dT" ~ "AAGCAGTGGTATCAACGCAGAGTNNNNNNNNCAGCAGGG",
    GROUP == "TSO-FS-UMI\nSS3-dT" ~ "AAGCAGTGGTATCAACGCAGAGTNNNNNNNNGGG")) %>%
    group_by(GROUP) %>%
  summarise(
    starts = 1:nchar(label),
    label = unlist(str_split(label, ""))
  ) %>% ungroup()

primer2 <- data_frame(
  GROUP = mygroups2,
  label = case_when(
    GROUP == "TSO-CAGCA\nSTRT-dT"~ "GAGTNNNNNNNNCAGCAGGG",
    GROUP == "TSO-AAGCA\nSTRT-dT"~ "GAGTNNNNNNNNAAGCAGGG",
    GROUP == "TSO-CATCA\nSTRT-dT" ~ "GAGTNNNNNNNNCATCAGGG",
    GROUP == "TSO-CTGAC\nSTRT-dT" ~ "GAGTNNNNNNNNCTGACGGG",
    GROUP == "TSO-ATGAC\nSTRT-dT" ~ "GAGTNNNNNNNNATGACGGG",
    GROUP == "TSO-CTAAC\nSTRT-dT" ~ "GAGTNNNNNNNNCTAACGGG",
    GROUP == "TSO-CAGCA\nFS-dT" ~ "GAGTNNNNNNNNCAGCAGGG",
    GROUP == "TSO-CAGCA\nSS3-dT" ~ "GAGTNNNNNNNNCAGCAGGG")) %>%
    group_by(GROUP) %>%
  summarise(
    starts = 1:nchar(label),
    label = unlist(str_split(label, ""))
  ) %>% ungroup()

primer3 <- data_frame(
  GROUP = mygroups2,
  label = case_when(
    GROUP == "TSO-CAGCA\nSTRT-dT"~ "GTNNNNNNNNCAGCAGGG",
    GROUP == "TSO-AAGCA\nSTRT-dT"~ "GTNNNNNNNNAAGCAGGG",
    GROUP == "TSO-CATCA\nSTRT-dT" ~ "GTNNNNNNNNCATCAGGG",
    GROUP == "TSO-CTGAC\nSTRT-dT" ~ "GTNNNNNNNNCTGACGGG",
    GROUP == "TSO-ATGAC\nSTRT-dT" ~ "GTNNNNNNNNATGACGGG",
    GROUP == "TSO-CTAAC\nSTRT-dT" ~ "GTNNNNNNNNCTAACGGG",
    GROUP == "TSO-CAGCA\nFS-dT" ~ "GTNNNNNNNNCAGCAGGG",
    GROUP == "TSO-CAGCA\nSS3-dT" ~ "GTNNNNNNNNCAGCAGGG")) %>%
    group_by(GROUP) %>%
  summarise(
    starts = 1:nchar(label),
    label = unlist(str_split(label, ""))
  ) %>% ungroup()

# Segments marking the read cut
mysegs <- data_frame(starts = rep(c(11, 13, 32), each = length(mygroups2)),
                     y = rep(c(0, 0, 0), each = length(mygroups2)),
                     yend = rep(c(100, 105, 110), each = length(mygroups2)),
                     GROUP = rep(mygroups2, 3))
                     
motifs <- motifs %>%
  group_by(ID) %>%
  mutate(total = n()) %>%
  group_by(GROUP, ID, starts) %>%
  summarise(starts.perc = 100*n()/unique(total)) %>%
  ungroup() %>%
  group_by(GROUP, starts) %>%
  summarise(mean = mean(starts.perc),
            sd = sd(starts.perc)) %>%
  filter(starts < 40) %>%
  ungroup()

p.motifs <- ggplot() + 
  geom_boxplot(data = motifs, aes(y = as.numeric(mean), x = as.factor(starts), fill = GROUP)) +
  xlab("Motif Position") +
  ylab("Mean Reads Percentage") +
  facet_wrap("GROUP") +
  theme_bw() +
  ylim(c(0,115)) +
  theme(legend.position = "none") +
  geom_text(data = primer, aes(x = starts, label = label), y = 110) +
  geom_text(data = primer2, aes(x = starts, label = label), y = 105) +
  geom_text(data = primer3, aes(x = starts, label = label), y = 100) +
  geom_segment(data = mysegs, aes(x = as.factor(starts), xend = as.factor(starts), y = 0, yend = yend), linetype = "dashed", color = "darkred") 


ggsave(p.motifs, filename = "/home/vincent.hahaut/data_storage/FS_intermediate_file/FIGURES/S1_Motif_Position.pdf", dpi = 300, height = 16, width = 24)
```
